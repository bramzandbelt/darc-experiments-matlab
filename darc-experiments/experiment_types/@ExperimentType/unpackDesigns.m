function unpackDesigns(obj, designs, exten)
%unpackDesigns
%
% unpackDesigns(obj, designs);
%
% Takes a row vector or matrix of designs and returns as seperate outputs for
% each variable in the appropriate order.  These returns are assigned
% directly to the namespace of the caller rather than being returned as an
% output using the names in obj.design_variables.  These are created as new
% variables if they do not already exist
%
% Number of columns of designs must correspond to the number of
% total variables (generally design should be generated by packDesigns).
%
% Inputs:
%       designs:  A matrix of designs. Each row is one design. Each column is a
%			different component of the design space.  Must either be the
%			same number as theta, or a single design
%   exten = An extension applied to the names of variables for if the
%           default names are already taken (e.g. we are considering both
%           previous and possible designs).  Empty by default
%
% Outputs:
%       direct variable assignment in the calling function.  Also generates
%       R_A when R_A_over_R_B and R_B both exist
%
% Tom Rainforth, 21/07/17

if ~exist('exten','var')
    exten = '';
end

n_names = numel(obj.design_variables);

for i=1:n_names
    if isempty(designs)
        assignin('caller',[obj.design_variables{i},exten],[]);
    else
        assignin('caller',[obj.design_variables{i},exten],designs(:,i));
    end
end

i_rs_over_rl = find(strcmpi(obj.design_variables,'R_A_over_R_B'));
i_rl = find(strcmpi(obj.design_variables,'R_B'));

if ~isempty(i_rs_over_rl) && ~isempty(i_rl)
    if isempty(designs)
        assignin('caller',['R_A',exten],[]);
    else
        assignin('caller',['R_A',exten],designs(:,i_rs_over_rl).*designs(:,i_rl));
    end
end

%% Checks
assert(i>=size(designs,2),'Too many design variables have been provided given the fixed parameters.');

end